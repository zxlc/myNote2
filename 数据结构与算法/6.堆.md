
## 堆

参考链接：[https://writings.sh/post/data-structure-heap-and-common-problems](https://writings.sh/post/data-structure-heap-and-common-problems)

堆是使用数组实现的二叉树，所以堆中没有父指针或子指针。

### 堆属性

- 堆是一个完全二叉树，每一层必须被填满之后才能开始下一层的填充
- 最大堆：所有父结点都大于或等于其子结点的值，第一个结点为最大值
- 最小堆：所有父结点都小于或等于其子结点的值，第一个结点为最小值

若结点在数组中索引为i，则
- 父结点索引为 (i-1)/2（向下取整）
- 左子结点索引为 2i+1
- 右子结点索引为 2i+2

### 堆和普通树的区别

结点顺序
- 二叉搜索树中的结点是有序的，父结点大于左子，小于右子，但堆中左右子结点不是有序的

搜索
- 因为堆不是有序的，所以搜索效率不如二叉搜索树

内存占用
- 堆是用数组存储的，结点关系通过数组索引确定，不需要左右子结点的指针，所有内存占用比树要少

### 基础操作

插入结点：
- 将新结点添加到数组尾部
- 将新结点进行堆上浮

删除结点：
- 用尾结点替换要删除的结点
- 将尾结点进行堆下沉

替换结点：
- 先删除要被替换的结点（删除操作）
- 将新结点插入（插入操作）
- 替换堆顶：只需要用新元素替换堆顶，然后进行堆下沉

以最小堆为例：
- 堆上浮：不断和父结点比较，若父结点更大，则交换位置，时间复杂度为 O(logn)
- 堆下沉：不断和左右子结点比较，与更小的子结点交换位置，时间复杂度为 O(logn)

### 堆化（堆的构建）

堆化：调整一个已知数组的元素使之符合堆的性质

有两种方式:
1. 自底向上的下沉
    - 时间复杂度 O(n)
    - 从最后一个父结点开始，不断与其子结点比较并调整位置（下沉）

2. 自上而下的上浮
    - 时间复杂度 O(nlogn)
    - 从第一个左子结点开始，不断与其父结点比较并调整位置（上浮）

### 常见应用

#### 堆排序

从小到大：将数组最大堆化，依次将第一个元素移到尾部

时间复杂度：O(nlogn)
稳定性：不稳定

#### TopK问题

经典问题，有多个变种：
- 从一个无序数组中找出第k大的数
- 从一个数据流中找出最大的k个数
- 从一个无序数组中找出中位数
- 从一个无序数组中找出出现次数最多的k个数

方法一：将数组最大堆化，从堆顶弹出k个元素
- 时间复杂度是 O(n + (k-1)logn) -> O(klogn)

方法二：将堆当作一个过滤器，最小堆可留住最大的数，最大堆可留住最小的数
- 建立大小为k的最小堆，然后将剩余的元素与堆顶进行比较，若比堆顶大，则替换堆顶，最后堆中剩下的就是k个最大数
- 时间复杂度：O(k + (n-k)logk) -> O(nlogk)

在数据集大小未知的情况下，比如数据流中找最大的k个数时，数据相对随机的情况下，第二种方法的堆调整次数会更少。此外，第二种方法对空间的要求更小。
