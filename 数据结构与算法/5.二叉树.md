
## 二叉树

树：树的每一个节点有一个值和一个包含所有子节点的列表，从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。
- 节点的深度：从树的根节点到该节点的边数
- 节点的高度：该节点和叶子之间最长路径上的边数
- 树的高度：其根节点的高度

二叉树：二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”

### 二叉树的遍历

1. 前序遍历：根 > 左 > 右
2. 中序遍历：左 > 根 > 右
3. 前序遍历：左 > 右 > 根
4. 层序遍历：
  - 从根节点开始，首先访问节点本身，然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推
  - 广度优先搜索访问节点的顺序就是按照层序遍历的访问顺序

深度优先遍历：
- 时间复杂度：O(n)，n 为节点数
- 空间复杂度：O(h)，h 为树的最大深度，平均情况下为 O(logn)，最坏情况下树呈现链状为 O(n)

广度优先遍历：
- 时间复杂度：O(n)，n 为节点数
- 空间复杂度：O(b)，b 为树的最大广度

## 二叉搜索树

1. 概念
二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：
- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 任意结点的左、右子树也分别为二叉查找树。
- 没有键值相等的结点（no duplicate nodes）。

2. 操作
- 中序遍历是二叉搜索树中最常用的遍历方法，可以通过中序遍历遍历二叉搜索树得到一个递增的有序序列
- 二叉搜索树的搜索、插入、删除操作时间复杂度为 O(h)，树的高度决定了查找效率

3. 适用情景
- 需要有序地存储数据
- 或者需要同时执行搜索、插入、删除等多个操作

### 验证二叉搜索树

```
// 中序遍历，依据节点访问的顺序节点的值递增
    public boolean isValidBST(TreeNode root) {
        if (null == root) {
            return true;
        }
        Stack<TreeNode> stack = new Stack();
        stack.push(root);
        Set<TreeNode> acceedSet = new HashSet();
        TreeNode lastNode = null;
        while(!stack.isEmpty()) {
            TreeNode node = stack.peek();
            if (null != node.left && !acceedSet.contains(node.left)) {
                stack.push(node.left);
                continue;
            }
            node = stack.pop();
            if (null != lastNode) {
                if (!(lastNode.val < node.val)) {
                    return false;
                }
            }
            acceedSet.add(node);
            lastNode = node;
            if (null != node.right) {
                stack.push(node.right);
            }
        }
        return true;
    }
```

### 插入节点

主要思想是为目标节点找出合适的叶节点位置，然后将该节点作为叶节点插入

### 删除节点

用一个合适的子节点来替换要删除的目标节点：
- 如果目标节点没有子节点，我们可以直接移除该目标节点
- 如果目标节有右子节点，我们可以用其中序后继节点作为替换
- 如果目标节只有左子节点，我们可以用其中序前驱节点作为替换

## 红黑树

### 平衡二叉搜索树

平衡二叉搜索树（高度平衡的二叉搜索树）：在插入或删除任何节点后自动保持其高度最小，即有 N 个节点的平衡二叉搜索树，其高度是 logN

特性：每个节点的两个子树的高度相差不超过 1

常见的平衡二叉树：红黑树、AVL树、伸展树、树堆

> 一个普通的二叉搜索树在最坏的情况下可以退化成一个链，因此具有 N 个节点的二叉搜索树其高度在 logN 到 N 之间变化，也就是说其搜索操作的时间复杂度可以从 logN 变化到 N，这是一个巨大的性能差异。所以高度平衡的二叉搜索树对提高性能起着重要作用。

### 红黑树

红黑树，本质上是一棵二叉查找树，但它在二叉查找树的基础上为各节点增加了颜色属性，并满足相关性质以使得树相对平衡，从而保证查找、插入和删除的时间复杂度一直为 O(log n)。

Java中的相关类：TreeMap、TreeSet、HashMap、HashSet

#### 性质

1. 所有节点要么是黑色，要么是红色
2. 根节点是黑色
3. 所有空节点是黑色
4. 如果一个节点是红色，那么它的父节点与子节点必须是黑色
5. 从某个节点到其叶子节点的所有路径上包含的黑节点个数相等

原理：
https://www.cnblogs.com/skywang12345/p/3245399.html

https://tech.meituan.com/2016/12/02/redblack-tree.html
