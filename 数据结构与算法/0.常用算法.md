# 常用算法

## 排序

十大排序算法总结 [https://www.cnblogs.com/guoyaohua/p/8600214.html](https://www.cnblogs.com/guoyaohua/p/8600214.html)

### 冒泡排序

- 给定的一组数据中，从前到后对每相邻的两个元素进行比较，交换位置（正序排序 前者>后者时调换位置，倒序排序 前者<后者时调换位置），经过一轮处理，最后一个元素为最大值或最小值
- 排除后面已选出的元素，对剩下的元素重复以上过程，直到没有相邻元素为止。
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

```
// 确定比较元素范围
// 第一个元素索引：0
// 最后一个元素索引：len-1 到 1，递减

for (int i = arr.length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {
        // 从大到小
        if (arr[j] < arr[j+1]) {
            int tmp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = tmp;
        }
    }
}
```

### 选择排序

- 从给定的一组数据中，比较出最大值或最小值后与第一个元素交换位置
- 去掉已选好的第一个元素，将剩下的数据进行第二轮比较，比较出最大值或最小值后与第二个元素交换位置
- 重复以上过程，直到只剩下一个元素为止。
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

```
// 确定比较范围：
// 第一个元素索引：0 到 len-2，递增
// 最后一个元素索引：len-1

for (int i = 0; i < arr.length - 1; i++) {
    // 从小到大，比较出最小值
    int value = arr[i];
    int index = i;

    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < value) {
            value = arr[j];
            index = j;
        }
    }

    // 与第i个元素交换位置
    arr[index] = arr[i];
    arr[i] = value;
}
```

### 插入排序

- 在给定的一组数据，认为第一个元素已经排好序了，然后将后面的元素按照大小依次插入到前面的有序序列中，直到最后一个元素插入到序列中为止
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

```
// 确定待插入的元素索引范围：1 到 len - 1
for (int i = 1; i < arr.length; i++) {
    int value = arr[i];
    // 后移有序序列中较大的元素，插入当前元素
    for (int j = i; j >= 0; j--) {
        if (arr[j] > value) {
            arr[j + 1] = arr[j];  // 后移元素
            arr[j] = value;
        }
    }
}
```
### 希尔排序（缩小增量排序）

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序
- 首先选择一个增量序列，{n/2,(n/2)/2...1}，依次以序列中的增量为间隔将数据分成几个子序列，分别对这些子序列进行插入排序，直到增量为1时对整个数组进行一次插入排序
- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

### 归并排序

用递归的方式将数组折半分离成单个数组，再将分开的数据按照一定的顺序放到一个数组中。
- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)，拆分与合并时会创建新数组 + 系统调用栈

### 快速排序

- 先从数列中取出一个数作为key值；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
- 对左右两个小数列重复第二步，直至各区间只有1个数。

- 时间复杂度：O(nlogn)
- 空间复杂度：O(logn)，系统调用栈

### 桶排序

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，再分别对每个桶进行排序。桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
- 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值， n/size 为桶的数量；
- 遍历输入数据，根据映射函数把数据放到对应的桶里去；
- 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
- 从不是空的桶里把排好序的数据拼接起来。

- 时间复杂度：O(n+k)
- 空间复杂度：O(n+k)

![桶排序示例图](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png)

## 排序算法综合比较

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233043168-1867817869.png)
